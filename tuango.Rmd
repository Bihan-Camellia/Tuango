---
title: Tuango - RFM Analysis for Mobile App Push Messaging
output: html_document
---

* Name:
* GitLab id:
* GitLab username:

```{r r_setup, include = FALSE}
## initial settings
knitr::opts_chunk$set(
  comment = NA,
  echo = TRUE,
  error = TRUE,
  cache = FALSE,
  message = FALSE,
  dpi = 96,
  warning = FALSE
)

## width to use when printing tables etc.
options(
  width = 250,
  scipen = 100,
  max.print = 5000,
  stringsAsFactors = FALSE
)

## make all required libraries available by loading radiant package if needed
if (!exists("r_environment")) library(radiant)
```

```{css, echo = FALSE}
.table {
  width: auto;
}
ul, ol {
  padding-left: 18px;
}
pre, code, pre code {
  overflow: auto;
  white-space: pre;
  word-wrap: normal;
  background-color: #ffffff;
}
```

## Setup

Please complete this R-markdown document by answering the questions in `tuango.pdf` on Dropbox (week4/readings/). The code block below will load the data you will need. Create a Notebook/HTML file with all your results and comments and push both the R-markdown and Notebook/HTML file to GitLab when you are done. All results MUST be reproducible (i.e., the TA and I must be able to recreate the Notebook/HTML from the R-markdown file without changes or errors).

```{r}
## loading the data. Note that data must be loaded from Dropbox/MGTA455-2018/data
tuango_wrk <- readr::read_rds(file.path(find_dropbox(), "MGTA455-2018/data/tuango.rds"))

## Recall that Radiant stores all datasets in a list called r_data 
## if you are planning to use data transformation commands generated by radiant  
## uncomment the lines below and comment out the line above
# if (!exists("r_data")) r_data <- list()
# r_data[["tuango_wrk"]] <- readr::read_rds(file.path(find_dropbox(), "MGTA455-2018/data/tuango.rds"))
```

## Question answers

1. What percentage of customers responded (i.e., bought anything) after the push message?

3% of customers responded.

```{r}
result <- pivotr(
  dataset = "tuango_wrk", 
  cvars = "buyer", 
  normalize = "total", 
  nr = 2
)
summary(result)
# dtab(result) %>% render()
# store(result, name = "tuango_wrk_pvt")
```


2. What was the average amount spent on the Karaoke deal by customers that bought one (or more)? Use the ordersize variable for your calculation.

The average amount spent on Karaoke deal by customers that bought one or more is ￥202.13.

```{r}
result <- explore(
  dataset = "tuango_wrk", 
  vars = "ordersize", 
  byvar = "buyer", 
  fun = c("length", "mean_rm", "min_rm", "max_rm"), 
  nr = 2
)
summary(result)
# dtab(result) %>% render()
# store(result, name = "tuango_wrk_expl")
```


3. Create quintile variables for recency, frequency and monetary.
Tip: Make sure to store any transformations in a dataset “tuango_wrk” so the original “tuango” data remains clean

bar plot:

```{r fig.width = 7, fig.height = 7, dpi = 96}
visualize(
  dataset = "tuango_wrk", 
  xvar = "recency", 
  yvar = "buyer", 
  type = "bar", 
  custom = FALSE
)
```



```{r}
## create new variable(s) rec_iq
tuango_wrk <- tuango_wrk%>%
  mutate(rec_iq = xtile(recency,5))
```

```{r}
## create new variable(s) freq_iq
tuango_wrk <-tuango_wrk%>%
  mutate(freq_iq=xtile(frequency,5,rev=TRUE))
```


```{r}
## create new variable(s) mon_iq
tuango_wrk <-tuango_wrk%>%
  mutate(mon_iq=xtile(monetary,5,rev = TRUE))
```


4. Create bar charts showing the response rate (i.e., the proportion of customers who bought something) for this deal per recency, frequency, and monetary quintile (i.e., 3 plots).

```{r fig.width = 7, fig.height = 7, dpi = 96}
visualize(
  dataset = "tuango_wrk", 
  xvar = c("rec_iq", "freq_iq", "mon_iq"), 
  yvar = "buyer", 
  type = "bar", 
  custom = FALSE
)
```

5. Create bar charts showing the average amount spent (in RMB) (i.e., ordersize) per recency, frequency, and monetary quintile using only those customers who placed an order after the push message. Hint: constrain the data used for the plot with a “filter”.


```{r fig.width = 7, fig.height = 7, dpi = 96}
visualize(
  dataset = "tuango_wrk", 
  xvar = c("rec_iq", "freq_iq", "mon_iq"), 
  yvar = "ordersize", 
  type = "bar", 
  data_filter = "buyer=='yes'", 
  custom = FALSE
)
```

6. What do the above bar charts reveal about the likelihood of response and the size of the order across the different recency, frequency, and monetary quintiles?

We can look at the sorted graph.

```{r fig.width = 7, fig.height = 7, dpi = 96}
visualize(
  dataset = "tuango_wrk", 
  xvar = c("rec_iq", "freq_iq", "mon_iq"), 
  yvar = "ordersize", 
  type = "bar", 
  axes = "sort", 
  data_filter = "buyer=='yes'", 
  custom = FALSE
)
```


For monetary, indeed, the customer with a larger ordersize will have a higher response rate. 

However, for recency and frequency, this is not the case.

The customers from forth quintile of recency has the largest ordersize. The customers from fifth quintile of frequency has the second largest ordersize.

Create two RFM indices. First, create a variable rfm_iq using the independent n-tile approach. As a way to check you have done this correctly, compare your index to the variable rfm_iq_pre already in the dataset. Next, create a variable rfm_sq using the sequential n-tile approach. To compute this index, review the steps described for the Bookbinders case discussed in class.
The following questions will ask you to use data to predict the profit and the return on marketing expenditures from offering the deal to the remaining 250,902 potential customers (i.e., 278,780 – 27,878).

```{r}
## create new variable(s)
tuango_wrk <- tuango_wrk%>%
  mutate(rfm_iq=paste0(rec_iq,freq_iq,mon_iq))
```


```{r}
## create new variable(s) freq_sq
tuango_wrk <- tuango_wrk%>%
  group_by(rec_iq)%>%
  mutate(freq_sq=xtile(frequency,5,rev = TRUE)) %>%
  ungroup
```


```{r}
## create new variable(s)
tuango_wrk <- tuango_wrk%>%
  group_by(rec_iq,freq_sq) %>%
  mutate(mon_sq=xtile(monetary,5,rev=TRUE))%>%
  ungroup
```


```{r}
## create new variable(s)
tuango_wrk <- tuango_wrk%>%
  mutate(rfm_sq=paste0(rec_iq,freq_sq,mon_sq))
```


```{r}
visualize(
  dataset = "tuango_wrk", 
  xvar = "rfm_sq", 
  yvar = "buyer", 
  type = "bar", 
  custom = TRUE
) +
  labs(y = "Proportion of buyer = 'yes'", x = "Sequential RFM index (rfm_sq)") +
  theme(axis.text.x = element_text(angle = 90, hjust = 1))
```

To calculate profit and return on marketing expenditures assume the following:
Marginal cost to offer a deal is 1.6RMB
Fee on each deal sold is 50% of sales revenues


7. What is the breakeven response rate?


```{r}
breakeven <- 1.6/(mean(tuango_wrk$ordersize[tuango_wrk$ordersize!=0])*0.5)
```


The breakeven response rate is `r round(breakeven,4)*100`%.

8. What is the projected profit in RMB and the return on marketing expenditures if you offer
the deal to all 250,902 remaining customers?


```{r}
result <- explore(
  dataset = "tuango_wrk", 
  vars = "buyer", 
  fun = c("length", "mean_rm", "min_rm", "max_rm")
)
summary(result, dec = 4)
```


```{r}
dat <- tuango_wrk
perc_sms = 1
nr_sms = 250902 * perc_sms
rep_rate = mean(dat$buyer == "yes")
nr_resp = nr_sms * rep_rate
sms_cost = 1.6 * nr_sms
profit_nt = mean(filter(tuango_wrk,tuango_wrk$ordersize!=0)$ordersize)*0.5* nr_resp - sms_cost
ROME_nt = profit_nt / sms_cost
```

Without targeting tuango would mail all `r nr_sms` remaining customers (`r 100*perc_sms`%). The response rate is predicted to be `r round(rep_rate,4)*100`% or `r nr_resp` buyers. The expected profit is $`r profit_nt`. The sms cost is estimated to be $`r sms_cost` with a ROME of `r round(ROME_nt,4)`.

9. Evaluate the performance implications of offering the deal to only those customers (out
of 250,902) in RFM cells with a response rate greater than the breakeven response rate. 5
 
Generate your result based on both sequential and independent RFM. Determine the projected profit in RMB and the return on marketing expenditures for each approach.
Hint: As you will be evaluating multiple “models” in this exercise, it will be useful to define a function (call it “perf_calc”) that does all the calculations, and that can be re-used for each model. Even better, would be if the function also generates the text to be printed for each “model” with all information about response rates, costs, profit, ROME, etc. Below an example of what the call to such a function might look like. The last line (i.e., “cat(...)” would print the required text output. “profit_sq” and “ROME_sq” can be used in performance plots (see question 13 below).

```{r}
tuango_wrk <- tuango_wrk%>%
  group_by(rfm_iq)%>%
  mutate(smsto_iq = mean(buyer == "yes") > breakeven)%>%
  ungroup()
```

```{r}
result <- explore(
  dataset = "tuango_wrk", 
  vars = "buyer", 
  byvar = "smsto_iq", 
  fun = c("length", "mean_rm")
)
summary(result, dec = 4)
```


```{r}
tuango_wrk <- tuango_wrk%>%
  group_by(rfm_sq)%>%
  mutate(smsto_sq = mean(buyer == "yes") > breakeven)%>%
  ungroup()
```


```{r}
result <- explore(
  dataset = "tuango_wrk", 
  vars = "buyer", 
  byvar = "smsto_sq", 
  fun = c("length", "mean_rm")
)
summary(result, dec = 4)
```



```{r}
perf_calc <- function(sms, intro){
  dat = tuango_wrk
  perc_sms =  mean(dat[[sms]]==TRUE)
  nr_sms = 250902 * perc_sms
  dat = dat[dat[[sms]]==TRUE,]
  rep_rate = mean(dat$buyer == "yes")
  nr_resp = nr_sms * rep_rate
  sms_cost = 1.6 * nr_sms
  avg= mean(tuango_wrk$ordersize[tuango_wrk$ordersize!=0])*0.5
  profit = avg * nr_resp - sms_cost
  ROME = profit / sms_cost
  prn <- paste(intro,"the number of customers tuango should mail is",nr_sms, "(",round(perc_sms,4)*100, "%). The response rate for the selected customers is predicted to be", round(rep_rate,4)*100, "% or", nr_resp, "buyers. The expected profit is $",profit, ", The mailing cost is estimated to be $", sms_cost, "with a ROME of ", round(ROME,4), ".")
  result <- list(profit=profit,ROME=ROME,prn=prn)
  return(result)
}
```


```{r results = "asis"}
res <- perf_calc(sms = "smsto_sq", intro = "Based on sequential RFM") 
profit_sq <- res$profit
ROME_sq <- res$ROME
cat(res$prn)
```

```{r results = "asis"}
res <- perf_calc(sms = "smsto_iq", intro = "Based on sequential RFM") 
profit_iq <- res$profit
ROME_iq <- res$ROME
cat(res$prn)
```

10. What do you notice when you compare the rfm_iq and rfm_sq variables? That is – do the two approaches generally yield the same RFM index for any given customer? What do you see as the pros and cons of the two approaches (from a statistical as well as logical perspective) and why?

```{r}
sum(tuango_wrk$rfm_iq==tuango_wrk$rfm_sq)
```

The two approach don't yield the same RFM index generally speaking. The number of cusomer with different rfm codes occupies more than 50% of the test group.

Independent RFM is easier and simpler to understand. The three ranks are assigned independently. The interpretation of each of the three RFM components is therefore unambiguous. For smaller samples, this has the disadvantage of resulting in a less even distribution of combined RFM scores because all the "good" customers will gather together in certain groups.

In sequential binning, a simple rank is assigned to recency values.  This tends to provide a more even distribution of combined RFM scores, but it has the disadvantage of making frequency and monetary rank scores more difficult to interpret. It's difficult to compare a frequency rank of 5 for a customer with a recency rank of 5 may not mean the same thing as a frequency rank of 5 for a customer with a recency rank of 4, since the frequency rank is dependent on the recency rank.


11. The answer to question 9 assumes a single breakeven response rate that applies across all cells. Redo your analysis for sequential RFM based on a breakeven response rate calculated for each RFM cell.

For this question, I calculate the breakeven responde rate for each RFM cell. However, I assume the margin on sale remains the same and doesn't change in each RFM cell although some RFM cells (eg. "111) must have higher margin than other groups(eg."555"). Without change the margin on sale, we can say the only difference between each model are how to define RFM and how to choose RFM cells to send promotions.

```{r}
tuango_wrk <- tuango_wrk%>%
  group_by(rfm_sq)%>%
  mutate(breakeven_125= 1.6/(0.5*mean(ordersize[ordersize!=0])))

tuango_wrk$breakeven_125[is.nan(tuango_wrk$breakeven_125)] <- 0

tuango_wrk <- tuango_wrk%>%
  group_by(rfm_sq)%>%
  mutate(resp_rate= mean(buyer=="yes"),
         smsto_sq2=resp_rate>breakeven_125)
```

```{r results = "asis"}
res <- perf_calc(sms = "smsto_sq2", intro = "Based on sequential RFM for each RFM cell") 
profit_sq2 <- res$profit
ROME_sq2 <- res$ROME
cat(res$prn)
```

The profit abd ROME for sequential RFM based on a breakeven response rate calculated for each RFM cell is $449379 and 1.97% respective.

However, I still want to have a look at the profit and ROME based on both breakeven respond rates and margin on cells for each cell. So I create perf_calc2 function, which creates breakeven respond rate and margin on sale for each RFM cell respectively.

```{r}
perf_calc2 <- function(sms, intro){
  dat = tuango_wrk
  model_name <- substr(sms,start =  7, stop =nchar(sms))
  code <- paste0("rfm_",model_name)
  dat <- dat%>%
    group_by_(code)%>%
    mutate(margin_avg=0.5*mean(ordersize[ordersize!=0]),
           breakeven_125= 1.6/(0.5*mean(ordersize[ordersize!=0])))
  dat <- dat%>%
    mutate(whether_sms=mean(buyer == "yes") > breakeven_125)%>%
    ungroup()
dat$breakeven_125[is.nan(dat$breakeven_125)] <- 0
dat$margin_avg[is.nan(dat$margin_avg)] <- 0
dat$whether_sms[is.na(dat$whether_sms)] <- FALSE
perc_sms =  mean(dat[["whether_sms"]]==TRUE)
  nr_sms = 250902 * perc_sms
  dat2 = dat[dat[["whether_sms"]]==TRUE,]
  rep_rate = mean(dat2$buyer == "yes")
  nr_resp = nr_sms * rep_rate
  sms_cost = 1.6 * nr_sms
  dat3 <- dat[dat$whether_sms==TRUE,]
  selected <- unique(dat3[[code]])
  dat <- dat%>%
    summarise(profit = mean(margin_avg) * nr_resp - sms_cost,
              ROME = profit / sms_cost)
  prn <- paste(intro,"the number of customers tuango should mail is",nr_sms, "(", round(perc_sms,4)*100, "%). The response rate for the selected customers is predicted to be", round(rep_rate,4)*100, "% or", nr_resp, "buyers. The expected profit is $", dat$profit, ", The mailing cost is estimated to be $", sms_cost, "with a ROME of ", round(dat$ROME,4), "%.")
  result <- list(profit=dat$profit,ROME=dat$ROME,prn=prn,model_name=model_name,code=code,perc_sms=perc_sms,nr_sms=nr_sms,rep_rate=rep_rate,nr_resp=nr_resp,sms_cost=sms_cost,selected=selected)
  return(result)
}
```

for that calculation, I have to create rfm_sq2.

```{r}
tuango_wrk <- tuango_wrk%>%
  mutate(rfm_sq2 = rfm_sq)
```


```{r results = "asis"}
res <- perf_calc2(sms = "smsto_sq2", intro = "Based on sequential RFM for each cell") 
profit_sq2_margin <- res$profit
ROME_sq2_margin <- res$ROME
selected_sq2_margin <- res$selected
cat(res$prn)
```

We can see without the average margin on sale, i.e., using different margin on sale for each RFM, the expected profit actually goes down, which means the average margin on sale in profit calculation indeed increase the expected profit.

12. The answer to question 9 does not account for the fact that the response rate for each cell is an estimated quantity (i.e., it has a standard error). Redo your analysis for both independent and sequential RFM, adjusting for the standard error of the response rate in each cell. What implications can you draw from the difference in predicted performance compared to question 9?

```{r}
result <- single_prop(
  dataset = "tuango_wrk", 
  var = "buyer", 
  lev = "yes", 
  comp_value = breakeven, 
  alternative = "greater", 
  data_filter = "rfm_iq == '111'"
)
summary(result)
```

The results show that we can reject *H0* in favor of the alternative hypothesis that the proportion of buyers in this group in the population will be above the break-even response rate.

The "worst" groups we should still send sms to was index 343 for rfm_iq. This group had a sample response rate of 1.78%. The test below shows that we can't reject H0 for this group.


```{r}
tuango_wrk%>%
  filter(rfm_iq=="343")%>%
  summarise(mean(buyer=="yes"))
```

```{r}
result <- single_prop(
  dataset = "tuango_wrk", 
  var = "buyer", 
  lev = "yes", 
  comp_value = breakeven, 
  alternative = "greater", 
  data_filter = "rfm_iq == '343'"
)
summary(result)
```

We can't reject the *H0* hypothesis becaue the p.value is larger than 0.05. Thus, we can't say the responde rate for this group is significantly larger than the breakeven responde rate.

Considering the standardard error, we want to make sure within in the group of sending promotions, the lowever bound on the response rate for each cell is above the breakeven response rate.

We can generate the required inputs to calculate the lower-bound on the response rate for each cell as follows:

```{r}
tuango_wrk_lbiq <- tuango_wrk%>%
  group_by(rfm_iq)%>%
  mutate(prop=mean(buyer=="yes"),
    prop_lb= prop-1.64*seprop(buyer=="yes"),
    smsto_lbiq= prop_lb>breakeven)
```

```{r}
tuango_wrk_lbsq <- tuango_wrk%>%
  group_by(rfm_sq)%>%
  mutate(prop=mean(buyer=="yes"),
    prop_lb= prop-1.64*seprop(buyer=="yes"),
    smsto_lbsq= prop_lb>breakeven)
```

```{r}
tuango_wrk <- tuango_wrk%>%
  group_by(rfm_iq)%>%
  mutate(prop_iq=mean(buyer=="yes"),
    prop_lbiq= prop_iq-1.64*seprop(buyer=="yes"),
    smsto_lbiq= prop_lbiq>breakeven)
tuango_wrk <- tuango_wrk%>%
  group_by(rfm_sq)%>%
  mutate(prop_sq=mean(buyer=="yes"),
    prop_lbsq= prop_sq-1.64*seprop(buyer=="yes"),
    smsto_lbsq= prop_lbsq>breakeven)
```


The figure below shows instances where the lower-bound of the confidence interal around the response rate for a cell is below the break-even cut-off point although the sample response rate is above the cut-off point.

```{r}
visualize(
  dataset = "tuango_wrk_lbiq", 
  xvar = "rfm_iq", 
  yvar = c("prop", "prop_lb"), 
  comby = TRUE, 
  type = "line", 
  custom = TRUE
) +
  geom_hline(yintercept = 0.083) +
  labs(
    y = "Proportion of buyer = 'yes'", 
    x = "Independent RFM index (rfm_iq)", 
    color = ""
  ) +
  theme(axis.text.x = element_text(angle = 90, hjust = 1))
```

```{r}
visualize(
  dataset = "tuango_wrk_lbsq", 
  xvar = "rfm_sq", 
  yvar = c("prop", "prop_lb"), 
  comby = TRUE, 
  type = "line", 
  custom = TRUE
) +
  geom_hline(yintercept = 0.083) +
  labs(
    y = "Proportion of buyer = 'yes'", 
    x = "Independent RFM index (rfm_iq)", 
    color = ""
  ) +
  theme(axis.text.x = element_text(angle = 90, hjust = 1))
```

13. Create a bar plot with all profit and ROME numbers for the analysis conducted in questions 9, 11, and 12

First I calculate the profit and ROME for lower-bound independent quintile and lower-bound sequential quintile seperately using perf_calc function created above.

```{r results = "asis"}
res <- perf_calc(sms = "smsto_lbiq", intro = "Based on sequential RFM for each RFM cell") 
profit_lbiq <- res$profit
ROME_lbiq <- res$ROME
cat(res$prn)
```

```{r results = "asis"}
res <- perf_calc(sms = "smsto_lbsq", intro = "Based on sequential RFM for each RFM cell") 
profit_lbsq <- res$profit
ROME_lbsq <- res$ROME
cat(res$prn)
```

```{r}
## make a tibble (data.frame) with results
tuango_results <- tibble::tibble(
  name = c("No targeting", "Indep. RFM", "Sequen. RFM", "Sequen. RFM on each cell", "Indep. lb RFM", "Seq. lb RFM"),
  Profit = c(profit_nt, profit_iq, profit_sq, profit_sq2, profit_lbiq, profit_lbsq),
  ROME = c(ROME_nt, ROME_iq, ROME_sq, ROME_sq2, ROME_lbiq, ROME_lbsq)
) %>% 
  mutate(name = factor(name, levels = name))
```

```{r}
visualize(
  dataset = "tuango_results", 
  xvar = "name", 
  yvar = "Profit", 
  type = "bar", 
  custom = TRUE
) +
  labs(title = "Campaign profit", x = "") +
  geom_text(aes(label = formatnr(Profit, dec = 0)), vjust = 2)
```

```{r}
visualize(
  dataset = "tuango_results", 
  xvar = "name", 
  yvar = "ROME", 
  type = "bar", 
  custom = TRUE
) +## plot ROME
  labs(title = "Return on Marketing Expenditures (ROME)", x = "") +
  geom_text(aes(label = formatnr(ROME, dec = 2)), vjust = 2)
```

We can see that lower-bound rfm have comparably higher ROME but lower expected profit.

14. You also have access to a dataset with the results from the SMS roll-out (tuango_post.rds). Tuango actually contacted all 250,902 customers. The data has a “training” variable (training = 1 for the data used in the test, training = 0 for the remaining customers). You can use this variable to help evaluate the actual performance for each of the different RFM approaches. Re-create the plot in question 13 based on this new dataset. Use the “tuango_post.Rmd” Rmarkdown file to answer the question and conduct all analyses. You should be able to re-use most of your code and text from “tuango.Rmd”. However, there will likely be a few changes to your “perf_calc” function. Make sure to check that your “rfm_iq” variable is the same as “rfm_iq_pre” in the “tuango_post.rds” dataset.
It is important to note that, you should not use information about buyers that were not in the test sample (i.e., training == 0) to calculate the break-even response rate etc. for targeting. To help deal with this issue, create the variables “buyer_test” and “ordersize_test” as defined below:


buyer_test = ifelse(training == 1, ifelse(buyer == "yes", 1, 0), NA) ordersize_test = ifelse(training == 1 & buyer == "yes", ordersize, NA)


