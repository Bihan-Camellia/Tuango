---
title: Tuango - RFM Analysis for Mobile App Push Messaging on the post roll-out data
output: html_document
---

* Name:
* GitLab id:
* GitLab username:

```{r r_setup, include = FALSE}
## initial settings
knitr::opts_chunk$set(
  comment = NA,
  echo = TRUE,
  error = TRUE,
  cache = FALSE,
  message = FALSE,
  dpi = 96,
  warning = FALSE
)

## width to use when printing tables etc.
options(
  width = 250,
  scipen = 100,
  max.print = 5000,
  stringsAsFactors = FALSE
)

## make all required libraries available by loading radiant package if needed
if (!exists("r_environment")) library(radiant)
```

```{css, echo = FALSE}
.table {
  width: auto;
}
ul, ol {
  padding-left: 18px;
}
pre, code, pre code {
  overflow: auto;
  white-space: pre;
  word-wrap: normal;
  background-color: #ffffff;
}
```

## Setup

Please complete this R-markdown document by answering question 14 in `tuango.pdf` on Dropbox (week4/readings/). The code block below will load the data you will need. Create a Notebook/HTML file with all your results and comments and push both the R-markdown and Notebook/HTML file to GitLab when you are done. All results MUST be reproducible (i.e., the TA and I must be able to recreate the Notebook/HTML from the R-markdown file without changes or errors).

```{r}
## loading the data. Note that data must be loaded from Dropbox/MGTA455-2018/data
tuango_wrk <- readr::read_rds(file.path(find_dropbox(), "MGTA455-2018/data/tuango_post.rds"))

## Recall that Radiant stores all datasets in a list called r_data 
## if you are planning to use data transformation commands generated by radiant  
## uncomment the lines below and comment out the line above
# if (!exists("r_data")) r_data <- list()
# r_data[["tuango_wrk"]] <- readr::read_rds(file.path(find_dropbox(), "MGTA455-2018/data/tuango_post.rds"))
```


You also have access to a dataset with the results from the SMS roll-out (tuango_post.rds). Tuango actually contacted all 250,902 customers. The data has a “training” variable (training = 1 for the data used in the test, training = 0 for the remaining customers). You can use this variable to help evaluate the actual performance for each of the different RFM approaches. Re-create the plot in question 13 based on this new dataset. Use the “tuango_post.Rmd” Rmarkdown file to answer the question and conduct all analyses. You should be able to re-use most of your code and text from “tuango.Rmd”. However, there will likely be a few changes to your “perf_calc” function. Make sure to check that your “rfm_iq” variable is the same as “rfm_iq_pre” in the “tuango_post.rds” dataset.
It is important to note that, you should not use information about buyers that were not in the test sample (i.e., training == 0) to calculate the break-even response rate etc. for targeting. To help deal with this issue, create the variables “buyer_test” and “ordersize_test” as defined below:

## Question answers

```{r}
tuango_wrk <- tuango_wrk%>%
  mutate(
buyer_test = ifelse(training == 1, ifelse(buyer == "yes", 1, 0), NA),
ordersize_test = ifelse(training == 1 & buyer == "yes", ordersize, NA))
```


Create rfm_iq:

```{r}
## create new variable(s) rec_iq
tuango_wrk <- tuango_wrk%>%
  mutate(rec_iq = xtile(recency,5))
```

```{r}
## create new variable(s) freq_iq
tuango_wrk <-tuango_wrk%>%
  mutate(freq_iq=xtile(frequency,5,rev=TRUE))
```

```{r}
## create new variable(s) mon_iq
tuango_wrk <-tuango_wrk%>%
  mutate(mon_iq=xtile(monetary,5,rev = TRUE))
```

```{r}
## create new variable(s)
tuango_wrk <- tuango_wrk%>%
  mutate(rfm_iq=paste0(rec_iq,freq_iq,mon_iq))
```

Create rfm_sq:

```{r}
## create new variable(s) freq_sq
tuango_wrk <- tuango_wrk%>%
  group_by(rec_iq)%>%
  mutate(freq_sq=xtile(frequency,5,rev = TRUE)) %>%
  ungroup()
```


```{r}
## create new variable(s)
tuango_wrk <- tuango_wrk%>%
  group_by(rec_iq,freq_sq) %>%
  mutate(mon_sq=xtile(monetary,5,rev=TRUE))%>%
  ungroup()
```


```{r}
## create new variable(s)
tuango_wrk <- tuango_wrk%>%
  mutate(rfm_sq=paste0(rec_iq,freq_sq,mon_sq))
```

```{r}
sum(tuango_wrk$rfm_iq_pre==tuango_wrk$rfm_iq)
```

```{r}
tuango_wrk <- tuango_wrk%>%
  mutate(rfm_lbiq=rfm_iq,
         rfm_lbsq=rfm_sq,
         rfm_sq2=rfm_sq)
```

Devide the dataset into two parts. The training data set has 27278 records and the test data set has 250902 records.

```{r}
training <- tuango_wrk[tuango_wrk$training==1,]
breakeven <- 1.6/(mean(training$ordersize[training$ordersize!=0])*0.5)
```

Decicde whether to send promotions for a certain rfm code.


```{r}
tuango_wrk <- tuango_wrk%>%
  group_by(rfm_iq)%>%
  mutate(smsto_iq = mean(buyer == "yes") > breakeven)%>%
  ungroup()
```

```{r}
tuango_wrk <- tuango_wrk%>%
  group_by(rfm_sq)%>%
  mutate(smsto_sq = mean(buyer == "yes") > breakeven)%>%
  ungroup()
```

```{r}
tuango_wrk <- tuango_wrk%>%
  group_by(rfm_sq)%>%
  mutate(breakeven_125= 1.6/(0.5*mean(ordersize[ordersize!=0])))%>%
  ungroup()

tuango_wrk$breakeven_125[is.nan(tuango_wrk$breakeven_125)] <- 0

tuango_wrk <- tuango_wrk%>%
  group_by(rfm_sq)%>%
  mutate(resp_rate= mean(buyer=="yes"),
         smsto_sq2=resp_rate>breakeven_125)%>%
  ungroup()
```


```{r}
tuango_wrk <- tuango_wrk%>%
  group_by(rfm_iq)%>%
  mutate(prop=mean(buyer=="yes"),
    prop_lb= prop-1.64*seprop(buyer=="yes"),
    smsto_lbiq= prop_lb>breakeven)
```

```{r}
tuango_wrk <- tuango_wrk%>%
  group_by(rfm_sq)%>%
  mutate(prop=mean(buyer=="yes"),
    prop_lb= prop-1.64*seprop(buyer=="yes"),
    smsto_lbsq= prop_lb>breakeven)
```

Performance calculation function. In order to increase the comparability of models, I ignore the influence that different rfm cell has different margin on sale. I just use average margin on sale in training dataset to calculate the *expected profit* for the rest 250902 customers.

I changed the function by adding variable *selected* to indicate the group of rfm cells that should be chosen in each model for further test.


```{r}
perf_calc <- function(sms, intro){
  dat = tuango_wrk[tuango_wrk$training==1,]
  model_name <- substr(sms,start =  7, stop =nchar(sms))
  code <- paste0("rfm_",model_name)
  perc_sms =  mean(dat[[sms]]==TRUE)
  nr_sms = 250902 * perc_sms
  dat = dat[dat[[sms]]==TRUE,]
  rep_rate = mean(dat$buyer == "yes")
  nr_resp = nr_sms * rep_rate
  sms_cost = 1.6 * nr_sms
  avg= mean(tuango_wrk$ordersize[tuango_wrk$ordersize!=0])*0.5
  profit = avg * nr_resp - sms_cost
  ROME = profit / sms_cost
  dat3 <- dat[dat[[sms]]==TRUE,]
  selected <- unique(dat3[[code]])
  prn <- paste(intro,"the number of customers tuango should mail is",nr_sms, "(",round(perc_sms,4)*100, "%). The response rate for the selected customers is predicted to be", round(rep_rate,4)*100, "% or", nr_resp, "buyers. The expected profit is $",profit, ", The mailing cost is estimated to be $", sms_cost, "with a ROME of ", round(ROME,4), ".")
  result <- list(profit=profit,ROME=ROME,prn=prn,selected=selected)
  return(result)
}
```

Now we can dive into the test dataset with 250902 customers.

First we gather all the selected rfm cells for each model.

```{r results = "asis"}
res<- perf_calc(sms = "smsto_iq", intro = "Based on independent RFM") 
profit_iq <- res$profit
ROME_iq <- res$ROME
selected_iq <- res$selected
cat(res$prn)
```


```{r results = "asis"}
res <- perf_calc(sms = "smsto_sq", intro = "Based on sequential RFM") 
profit_sq <- res$profit
ROME_sq <- res$ROME
selected_sq <- res$selected
cat(res$prn)
```

```{r results = "asis"}
res <- perf_calc(sms = "smsto_sq2", intro = "Based on sequential RFM for each cell") 
profit_sq2 <- res$profit
ROME_sq2 <- res$ROME
selected_sq2 <- res$selected
cat(res$prn)
```


```{r results = "asis"}
res <- perf_calc(sms = "smsto_lbiq", intro = "Based on lower-bound independent quintile rfm") 
profit_lbiq <- res$profit
ROME_lbiq <- res$ROME
selected_lbiq <- res$selected
cat(res$prn)
```

```{r results = "asis"}
res<- perf_calc(sms = "smsto_lbsq", intro = "Based on lower-bound sequential quintile rfm") 
profit_lbsq <- res$profit
ROME_lbsq <- res$ROME
selected_lbsq <- res$selected
cat(res$prn)
```




Using the selected RMF code for each model, I calculate the actual profit and ROME within in 250902 customers.
I select customers who are in the chosen RFM groups and sum their ordersize as the actual revenue.
The number of customers that we send promotions is the number of all customer in those chosed RFM groups.

```{r}
dat_test_iq <- tuango_wrk[tuango_wrk$training==0,]
dat_test_iq <- dat_test_iq%>%
  ungroup()%>%
  filter(rfm_iq %in% selected_iq)%>%
  summarise(cost_iq_test = 1.6*n(),
            profit_iq_test = sum(ordersize)*0.5-cost_iq_test,
            ROME_iq_test= profit_iq_test/cost_iq_test)
```

```{r}
dat_test_sq <- tuango_wrk[tuango_wrk$training==0,]
dat_test_sq <- dat_test_sq%>%
  ungroup()%>%
  filter(rfm_sq %in% selected_sq)%>%
  summarise(cost_sq_test = 1.6*n(),
            profit_sq_test = sum(ordersize)*0.5-cost_sq_test,
            ROME_sq_test= profit_sq_test/cost_sq_test)
```


```{r}
dat_test_sq2 <- tuango_wrk[tuango_wrk$training==0,]
dat_test_sq2 <- dat_test_sq2%>%
  ungroup()%>%
  filter(rfm_sq2 %in% selected_sq2)%>%
  summarise(cost_sq2_test = 1.6*n(),
            profit_sq2_test = sum(ordersize)*0.5-cost_sq2_test,
            ROME_sq2_test= profit_sq2_test/cost_sq2_test)
```

```{r}
dat_test_lbiq <- tuango_wrk[tuango_wrk$training==0,]
dat_test_lbiq <- dat_test_lbiq%>%
  ungroup()%>%
  filter(rfm_lbiq %in% selected_lbiq)%>%
  summarise(cost_lbiq_test = 1.6*n(),
            profit_lbiq_test = sum(ordersize)*0.5-cost_lbiq_test,
            ROME_lbiq_test= profit_lbiq_test/cost_lbiq_test)
```

```{r}
dat_test_lbsq <- tuango_wrk[tuango_wrk$training==0,]
dat_test_lbsq <- dat_test_lbsq%>%
  ungroup()%>%
  filter(rfm_lbsq %in% selected_lbsq)%>%
  summarise(cost_lbsq_test = 1.6*n(),
            profit_lbsq_test = sum(ordersize)*0.5-cost_lbsq_test,
            ROME_lbsq_test= profit_lbsq_test/cost_lbsq_test)
```

Profit without targeting in test dataset.

```{r}
dat <- tuango_wrk[tuango_wrk$training==0,]
perc_sms = 1
nr_sms = 250902 * perc_sms
rep_rate = mean(dat$buyer_test == 1)
nr_resp = nr_sms * rep_rate
sms_cost = 1.6 * nr_sms
profit_nt = sum(ifelse(tuango_wrk$training==0,tuango_wrk$ordersize,0))*0.5 - sms_cost
ROME_nt = profit_nt / sms_cost
```

Without targeting tuango would mail all `r nr_sms` remaining customers (`r 100*perc_sms`%). The response rate is predicted to be `r round(rep_rate,4)*100`% or `r nr_resp` buyers. The expected profit is $`r profit_nt`. The sms cost is estimated to be $`r sms_cost` with a ROME of `r round(ROME_nt,4)`.


Finally, we can compare profits and ROME in different models.

```{r}
## make a tibble (data.frame) with results
tuango_results <- tibble::tibble(
  name = c("No targeting", "Indep. RFM", "Sequen. RFM", "Sequen. RFM on each cell", "Indep. lb RFM", "Seq. lb RFM"),
  Profit = c(profit_nt, dat_test_iq$profit_iq_test, dat_test_sq$profit_sq_test, dat_test_sq2$profit_sq2_test, dat_test_lbiq$profit_lbiq_test, dat_test_lbsq$profit_lbsq_test),
  ROME = c(ROME_nt, dat_test_iq$ROME_iq_test, dat_test_sq$ROME_sq_test, dat_test_sq2$ROME_sq2_test, dat_test_lbiq$ROME_lbiq_test, dat_test_lbsq$ROME_lbsq_test)
) %>% 
  mutate(name = factor(name, levels = name))
```

```{r}
visualize(
  dataset = "tuango_results", 
  xvar = "name", 
  yvar = "Profit", 
  type = "bar", 
  custom = TRUE
) +
  labs(title = "Campaign profit", x = "") +
  geom_text(aes(label = formatnr(Profit, dec = 0)), vjust = 2)
```

```{r}
visualize(
  dataset = "tuango_results", 
  xvar = "name", 
  yvar = "ROME", 
  type = "bar", 
  custom = TRUE
) +## plot ROME
  labs(title = "Return on Marketing Expenditures (ROME)", x = "") +
  geom_text(aes(label = formatnr(ROME, dec = 2)), vjust = 2)
```

We can see, actually, sequential rfm on each cell has the highest profit. The lower-bound rfm (both iq and sq) has a higher ROME as predicted.
